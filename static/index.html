<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; font-src 'self' data: blob: https:; img-src 'self' data: blob: https:; style-src 'self' 'unsafe-inline' https:;">
    <title>LG AI 챗봇 - 가전구독 할래? 말래?</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: url('bg.jpeg') center/cover no-repeat;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .chat-container {
            width: 600px;
            height: 700px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .chat-header {
            background: linear-gradient(135deg, #A50034, #8B0028, #6B0018);
            color: white;
            padding: 24px 20px;
            text-align: center;
            position: relative;
            box-shadow: 0 4px 20px rgba(165, 0, 52, 0.3);
        }
        
        .chat-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }
        
        .chat-header h1 {
            font-size: 20px;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.5px;
            position: relative;
            z-index: 1;
        }
        
        .chat-header .subtitle {
            font-size: 13px;
            opacity: 0.95;
            margin-top: 6px;
            font-weight: 400;
            position: relative;
            z-index: 1;
        }
        
        
        
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            padding: 0 16px;
        }
        
        .message.user {
            justify-content: flex-end;
        }
        
        .message.bot {
            justify-content: flex-start;
        }
        
        .message.subscription {
            justify-content: flex-end;
        }
        
        .message-content {
            max-width: 75%;
            padding: 10px 14px;
            border-radius: 20px;
            font-size: 15px;
            line-height: 1.3;
            word-wrap: break-word;
            font-weight: 400;
            letter-spacing: -0.01em;
        }
        
        .message.user .message-content {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 6px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .message.bot .message-content {
            background: #FFFFFF;
            color: #1d1d1f;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-bottom-left-radius: 6px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        .message.guide .message-content {
            background: #FFFFFF;
            color: #1d1d1f;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-bottom-left-radius: 6px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        .speaker-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .bot-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-bottom: 5px;
        }
        
        .speaker-name {
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }
        
        .guide-turn .speaker-info {
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .guide-turn .bot-avatar {
            margin-bottom: 5px;
        }
        
        .guide-name {
            color: #424242;
            font-weight: 600;
        }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            margin: 10px 0;
            background: #f8f9fa;
            border-radius: 18px;
            max-width: 60px;
        }
        
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            animation: typing 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }
        
        @keyframes typing {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .reset-section {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
        }
        
        .reset-button {
            background: linear-gradient(135deg, #A50034, #C41E3A);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(165, 0, 52, 0.3);
        }
        
        .reset-button:hover {
            background: linear-gradient(135deg, #C41E3A, #A50034);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(165, 0, 52, 0.4);
        }
        
        
        .message-content {
            position: relative;
        }
        
        
        
        .message.purchase .message-content {
            background: linear-gradient(135deg, rgba(0, 122, 255, 0.15), rgba(0, 122, 255, 0.08));
            color: #0056CC;
            border: 2px solid rgba(0, 122, 255, 0.3);
            border-bottom-left-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
            font-weight: 500;
        }
        
        .message.subscription .message-content {
            background: linear-gradient(135deg, rgba(52, 199, 89, 0.15), rgba(52, 199, 89, 0.08));
            color: #28A745;
            border: 2px solid rgba(52, 199, 89, 0.3);
            border-bottom-right-radius: 6px;
            box-shadow: 0 2px 8px rgba(52, 199, 89, 0.2);
            font-weight: 500;
        }
        
        .bot-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 8px;
            margin-left: 8px;
            border: 2px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .message.purchase .bot-avatar {
            border-color: rgba(0, 122, 255, 0.3);
        }
        
        .message.subscription .bot-avatar {
            border-color: rgba(52, 199, 89, 0.3);
            order: 2;
            margin-right: 0;
            margin-left: 8px;
        }
        
        .message.subscription .speaker-info {
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .message.subscription .speaker-info .bot-avatar {
            margin-bottom: 5px;
        }
        
        .message.user .bot-avatar {
            order: 2;
            margin-right: 0;
            margin-left: 12px;
        }
        
        .message.user .speaker-info {
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .message.user .speaker-info .bot-avatar {
            margin-bottom: 5px;
        }
        
        .chat-input {
            padding: 20px 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
            border-top: 2px solid rgba(165, 0, 52, 0.1);
            box-sizing: border-box;
            backdrop-filter: blur(25px);
            box-shadow: 0 -4px 20px rgba(165, 0, 52, 0.1);
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input[type="text"], select {
            flex: 1;
            padding: 14px 18px;
            border: 2px solid rgba(165, 0, 52, 0.15);
            border-radius: 24px;
            font-size: 15px;
            outline: none;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
            backdrop-filter: blur(15px);
            box-shadow: 0 2px 8px rgba(165, 0, 52, 0.1);
        }
        
        input[type="text"]:focus, select:focus {
            border-color: #A50034;
            box-shadow: 0 4px 16px rgba(165, 0, 52, 0.2);
            transform: translateY(-1px);
        }
        
        input[type="text"]:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
        }
        
        select {
            background: white;
            cursor: pointer;
        }
        
        button {
            padding: 14px 24px;
            background: linear-gradient(135deg, #A50034, #8B0028);
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 60px;
            box-shadow: 0 4px 16px rgba(165, 0, 52, 0.3);
            position: relative;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            background: linear-gradient(135deg, #8B0028, #6B0018);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(165, 0, 52, 0.4);
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        .clear-btn {
            background: #dc3545;
        }
        
        .clear-btn:hover {
            background: #c82333;
        }
        
        .product-selector {
            margin-bottom: 15px;
        }
        
        .product-info {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.95));
            padding: 16px;
            border-radius: 16px;
            margin: 8px auto;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 16px;
            border: 2px solid rgba(165, 0, 52, 0.1);
            width: calc(100% - 32px);
            max-width: 580px;
            box-sizing: border-box;
            backdrop-filter: blur(25px);
            box-shadow: 0 8px 24px rgba(165, 0, 52, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .product-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #A50034, #8B0028, #6B0018);
        }
        
        .product-image-container {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .product-info-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .product-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .product-name {
            font-size: 16px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 2px;
            letter-spacing: -0.01em;
        }
        
        .price-boxes {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .price-box {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.8));
            border-radius: 8px;
            padding: 8px 12px;
            text-align: center;
            border: 2px solid rgba(0, 0, 0, 0.08);
            min-width: 80px;
            flex: 1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .price-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }
        
        .purchase-box {
            background: linear-gradient(135deg, rgba(0, 122, 255, 0.1), rgba(0, 122, 255, 0.05));
            border-color: rgba(0, 122, 255, 0.25);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.2);
        }
        
        .subscription-box {
            background: linear-gradient(135deg, rgba(52, 199, 89, 0.1), rgba(52, 199, 89, 0.05));
            border-color: rgba(52, 199, 89, 0.25);
            box-shadow: 0 4px 12px rgba(52, 199, 89, 0.2);
        }
        
        .price-label {
            font-size: 10px;
            font-weight: 500;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }
        
        .purchase-box .price-label {
            color: #007AFF;
        }
        
        .subscription-box .price-label {
            color: #34C759;
        }
        
        .price-value {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 1px;
            color: #1d1d1f;
        }
        
        .contract-period {
            font-size: 9px;
            color: #86868b;
            margin-top: 1px;
            font-weight: 400;
        }
        
        .vs-divider {
            font-size: 11px;
            font-weight: 500;
            color: #86868b;
            padding: 0 4px;
            opacity: 0.6;
        }
        
        
        
        .hidden {
            display: none;
        }
        
        .speaker-name {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 5px;
            color: #666;
        }
        
        .guide-suggestion-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 16px 0;
            padding: 0 20px;
            align-items: flex-end;
        }
        
        .suggestion-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.9));
            border: 2px solid rgba(165, 0, 52, 0.15);
            border-radius: 16px;
            padding: 14px 20px;
            font-size: 15px;
            color: #1d1d1f;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
            max-width: 280px;
            font-weight: 500;
            box-shadow: 0 4px 16px rgba(165, 0, 52, 0.1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .suggestion-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
        }
        
        .suggestion-btn:hover {
            background: linear-gradient(135deg, rgba(165, 0, 52, 0.08), rgba(165, 0, 52, 0.05));
            border-color: rgba(165, 0, 52, 0.3);
            color: #A50034;
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(165, 0, 52, 0.2);
        }
        
        .suggestion-btn:hover::before {
            left: 100%;
        }
        
        .suggestion-btn:active {
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(165, 0, 52, 0.12), rgba(165, 0, 52, 0.08));
            box-shadow: 0 4px 16px rgba(165, 0, 52, 0.25);
        }
        
        .suggestion-btn.start-button {
            background: linear-gradient(135deg, rgba(165, 0, 52, 0.9), rgba(165, 0, 52, 0.8));
            border: 2px solid rgba(165, 0, 52, 0.3);
            color: white;
            font-weight: 600;
            font-size: 16px;
            padding: 16px 24px;
            min-width: 140px;
        }
        
        .suggestion-btn.start-button:hover {
            background: linear-gradient(135deg, rgba(165, 0, 52, 1), rgba(165, 0, 52, 0.9));
            border: 2px solid rgba(165, 0, 52, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(165, 0, 52, 0.4);
            color: white;
        }
        
        .suggestion-btn.start-button:active {
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(165, 0, 52, 0.95), rgba(165, 0, 52, 0.85));
            box-shadow: 0 4px 16px rgba(165, 0, 52, 0.5);
        }
        
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>가전구독 할래? 말래?</h1>
            <div class="subtitle">대신 정해드립니다.</div>
            <div style="margin-top: 10px;">
                <label style="color: white; font-size: 12px; cursor: pointer;">
                    <input type="checkbox" id="useImprovedFlow" style="margin-right: 5px; cursor: pointer;" checked>
                    개선된 대화 플로우 사용
                </label>
            </div>
        </div>
        
        <div id="productInfo" class="product-info hidden"></div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message bot guide guide-turn">
                <div class="speaker-info">
                    <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                    <span class="speaker-name guide-name">안내봇</span>
                </div>
                <div class="message-content">
                    구매와 구독 중 어떤 것이 더 나은지 애매하긴해! 우리가 구매vs구독 중에 제안해줄게.
                </div>
            </div>
        </div>
        
        <div class="chat-input">
            <div class="input-group">
                <input type="text" id="chatInput" placeholder="마음에 드는 답변이 없다면 직접 답변을 입력해보세요!" />
                <button onclick="sendUserInfo()" id="sendBtn">전송</button>
                <button onclick="endDebate()" class="clear-btn hidden" id="endChatBtn">종료</button>
            </div>
        </div>
    </div>

    <script>
        let isDebating = false;
        let currentTopic = '';
        let currentUserInfo = '';
        let accumulatedUserInfo = ''; // 누적된 사용자 정보
        let currentProduct = null;
        let products = [];
        let lastGuideQuestion = ''; // 마지막 안내봇 질문 저장
        let conversationHistory = []; // 대화 기록 저장
        let waitingForUser = false; // 사용자 응답 대기 상태
        
        async function startDebate() {
            const topic = document.getElementById('topicInput').value.trim();
            if (!topic) {
                alert('논쟁 주제를 입력해주세요!');
                return;
            }
            
            if (isDebating) {
                alert('이미 논쟁이 진행 중입니다!');
                return;
            }
            
            currentTopic = topic;
            isDebating = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'AI가 분석 중...';
            
            // 화면 초기화
            clearDebate();
            
            try {
                const response = await fetch('/debate/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        topic: currentTopic,
                        max_turns: 2
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() && line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (jsonStr) {
                                    const data = JSON.parse(jsonStr);
                                    await handleStreamData(data);
                                }
                            } catch (e) {
                                console.error('JSON parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error:', error);
                addStatusMessage('error', '애매하긴해');
            } finally {
                isDebating = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('startBtn').textContent = '논쟁 시작';
            }
        }
        
        async function startProductDebate() {
            console.log('startProductDebate 호출됨');
            console.log('currentProduct:', currentProduct);
            console.log('isDebating:', isDebating);
            
            if (!currentProduct) {
                alert('제품을 선택해주세요!');
                return;
            }
            
            if (isDebating) {
                alert('이미 논쟁이 진행 중입니다!');
                return;
            }
            
            isDebating = true;
            conversationHistory = []; // 대화 기록 초기화
            document.getElementById('sendBtn').disabled = true;
            document.getElementById('sendBtn').textContent = 'AI가 분석 중...';
            document.getElementById('chatInput').disabled = true;
            
            // 개선된 플로우 사용 여부 확인
            const useImproved = document.getElementById('useImprovedFlow').checked;
            const endpoint = useImproved ? '/product/debate/improved' : '/product/debate/stream';
            
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        product_id: currentProduct.id,
                        max_turns: 2
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() && line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (jsonStr) {
                                    const data = JSON.parse(jsonStr);
                                    await handleStreamData(data);
                                }
                            } catch (e) {
                                console.error('JSON parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error:', error);
                addStatusMessage('error', '애매하긴해');
            } finally {
                if (!waitingForUser) {
                    isDebating = false;
                    document.getElementById('sendBtn').disabled = false;
                    document.getElementById('sendBtn').textContent = '전송';
                    document.getElementById('chatInput').disabled = false;
                }
            }
        }

        function clearDebate() {
            document.getElementById('chatMessages').innerHTML = `
                <div class="message bot guide guide-turn">
                    <div class="speaker-info">
                        <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                        <span class="speaker-name guide-name">안내봇</span>
                    </div>
                    <div class="message-content">
                        안녕하세요! LG AI 챗봇입니다. 구매와 구독 중 어떤 것이 더 나은지 비교해드릴게요! 제품을 선택해주세요.
                    </div>
                </div>
            `;
        }

        async function generateContextualSuggestions() {
            // 안내봇의 마지막 질문에 따라 적절한 예상답안 생성
            console.log('generateContextualSuggestions 호출됨, lastGuideQuestion:', lastGuideQuestion);
            
            try {
                console.log('API 호출 시작:', lastGuideQuestion);
                console.log('현재 사용자 정보:', currentUserInfo);
                console.log('누적된 사용자 정보:', accumulatedUserInfo);
                const response = await fetch('/suggestions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        guide_message: lastGuideQuestion,
                        user_info: currentUserInfo || accumulatedUserInfo
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('API에서 받은 예상응답:', data.suggestions);
                    if (data.suggestions && data.suggestions.length >= 3) {
                        return data.suggestions;
                    } else {
                        console.error('예상응답이 부족함 (3개 필요):', data.suggestions);
                    }
                } else {
                    const errorText = await response.text();
                    console.error('예상응답 생성 실패:', response.status, errorText);
                }
            } catch (error) {
                console.error('예상응답 생성 오류:', error);
            }
            
            // API 실패 시에만 키워드 기반 로직 실행
            console.log('API 실패, 키워드 기반 로직으로 대체');
            
            const question = lastGuideQuestion.toLowerCase();
            console.log('안내봇 질문 분석:', question);
            
            // 구독 경험 관련 질문 (우선순위 높음)
            if (question.includes('이미') && question.includes('구독') && question.includes('있') ||
                question.includes('다른') && question.includes('가전') ||
                question.includes('첫') && question.includes('구독') ||
                question.includes('구독') && question.includes('도전')) {
                console.log('구독 경험 질문 감지');
                return [
                    '이미 다른 가전제품 구독하고 있어',
                    '이게 첫 구독 도전이야',
                    '이제 결론을 내줘'
                ];
            }
            
            // 주거 형태 관련 질문 (우선순위 높음)
            if (question.includes('아파트') || question.includes('단독주택') ||
                question.includes('주거') && question.includes('형태') ||
                question.includes('살아') || question.includes('거주') ||
                question.includes('설치') && question.includes('편의')) {
                console.log('주거 형태 질문 감지');
                return [
                    '아파트에 살고 있어',
                    '단독주택에 살고 있어',
                    '이제 결론을 내줘'
                ];
            }
            
            // 가족 구성원 관련 질문
            if (question.includes('가족') && (question.includes('몇') || question.includes('명')) ||
                question.includes('사람') && question.includes('몇') ||
                question.includes('혼자') && question.includes('살') ||
                question.includes('구성원')) {
                console.log('가족 구성 질문 감지');
                return [
                    '나 혼자 살고 있어',
                    '가족이 4명이야',
                    '이제 결론을 내줘'
                ];
            }
            
            // 예산/비용 관련 질문
            if (question.includes('예산') || 
                question.includes('돈') && (question.includes('얼마') || question.includes('가능')) ||
                question.includes('월') && (question.includes('비용') || question.includes('지출')) ||
                question.includes('비용') && question.includes('부담')) {
                console.log('예산 질문 감지');
                return [
                    '월 예산이 5만원이야',
                    '월 예산이 10만원이야',
                    '이제 결론을 내줘'
                ];
            }
            
            // 사용 패턴 관련 질문
            if (question.includes('사용') && (question.includes('자주') || question.includes('패턴')) ||
                question.includes('쓰') && question.includes('자주') ||
                question.includes('패턴') ||
                question.includes('어떻게') && question.includes('사용')) {
                console.log('사용 패턴 질문 감지');
                return [
                    '매일 자주 사용해',
                    '가끔만 사용해',
                    '이제 결론을 내줘'
                ];
            }
            
            // 거주/이사 관련 질문
            if (question.includes('이사') && (question.includes('자주') || question.includes('예정')) ||
                question.includes('이동') ||
                question.includes('거주') && (question.includes('안정') || question.includes('변화')) ||
                question.includes('집') && (question.includes('바꿀') || question.includes('이사'))) {
                console.log('거주/이사 질문 감지');
                return [
                    '자주 이사해',
                    '안정적으로 살고 있어',
                    '이제 결론을 내줘'
                ];
            }
            
            // 직업/생활 패턴 관련 질문
            if (question.includes('직업') || question.includes('일') && question.includes('하') ||
                question.includes('생활') && question.includes('패턴') ||
                question.includes('라이프스타일')) {
                console.log('직업/생활 패턴 질문 감지');
                return [
                    '직장인이야',
                    '주부야',
                    '이제 결론을 내줘'
                ];
            }
            
            // 나이/연령대 관련 질문
            if (question.includes('나이') || question.includes('연령') ||
                question.includes('몇') && question.includes('살') ||
                question.includes('대')) {
                console.log('나이/연령 질문 감지');
                return [
                    '20대야',
                    '30대야',
                    '이제 결론을 내줘'
                ];
            }
            
            console.log('기본 답변 사용');
            // 기본 답변
            return [
                '나 혼자 살고 있어',
                '가족이 4명이야',
                '이제 결론을 내줘'
            ];
        }

        function showImprovedSuggestionButtons(suggestions) {
            // 기존 제안 버튼들 제거
            const existingButtons = document.querySelector('.guide-suggestion-buttons');
            if (existingButtons) {
                existingButtons.remove();
            }
            
            // 제안 버튼들 컨테이너 생성
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'guide-suggestion-buttons';
            
            suggestions.forEach((suggestion, index) => {
                const button = document.createElement('button');
                button.className = 'suggestion-btn';
                button.textContent = suggestion;
                button.onclick = () => {
                    handleImprovedSuggestionClick(suggestion);
                };
                buttonsContainer.appendChild(button);
            });
            
            // 채팅 메시지 컨테이너에 추가
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(buttonsContainer);
            
            // 스크롤을 맨 아래로
            scrollToBottom();
        }
        
        async function handleImprovedSuggestionClick(suggestion) {
            // 제안 버튼들 숨기기
            const buttonsContainer = document.querySelector('.guide-suggestion-buttons');
            if (buttonsContainer) {
                buttonsContainer.remove();
            }
            
            // 사용자 메시지로 표시
            addUserMessage(suggestion);
            
            // 대화 기록에 추가
            conversationHistory.push({
                speaker: '사용자',
                message: suggestion,
                turn: conversationHistory.length + 1
            });
            
            // 개선된 플로우 응답 처리
            await sendImprovedResponse(suggestion);
        }
        
        async function sendImprovedResponse(userInput) {
            if (!currentProduct || !waitingForUser) return;
            
            waitingForUser = false;
            isDebating = true;
            document.getElementById('sendBtn').disabled = true;
            document.getElementById('sendBtn').textContent = 'AI가 생각 중...';
            document.getElementById('chatInput').disabled = true;
            
            try {
                const response = await fetch('/product/debate/improved/respond', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        product_id: currentProduct.id,
                        user_input: userInput,
                        conversation_history: conversationHistory
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\\n');
                    
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() && line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (jsonStr) {
                                    const data = JSON.parse(jsonStr);
                                    await handleStreamData(data);
                                }
                            } catch (e) {
                                console.error('JSON parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error:', error);
                addStatusMessage('error', '응답 처리 중 오류가 발생했습니다.');
            } finally {
                if (!waitingForUser) {
                    isDebating = false;
                    document.getElementById('sendBtn').disabled = false;
                    document.getElementById('sendBtn').textContent = '전송';
                    document.getElementById('chatInput').disabled = false;
                }
            }
        }

        async function addGuideSuggestionButtons() {
            // 기존 제안 버튼들 제거
            const existingButtons = document.querySelector('.guide-suggestion-buttons');
            if (existingButtons) {
                existingButtons.remove();
            }
            
            // 제안 버튼들 컨테이너 생성
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'guide-suggestion-buttons';
            
            // 맥락에 맞는 예상답안들
            console.log('예상답안 생성 시작');
            const suggestions = await generateContextualSuggestions();
            console.log('생성된 예상답안:', suggestions);
            
            suggestions.forEach((suggestion, index) => {
                const button = document.createElement('button');
                button.className = 'suggestion-btn';
                button.textContent = suggestion;
                button.onclick = () => {
                    // 버튼 클릭 시 해당 텍스트를 채팅창에 입력한 것과 같은 효과
                    handleSuggestionClick(suggestion);
                };
                buttonsContainer.appendChild(button);
            });
            
            // 채팅 메시지 컨테이너에 추가
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(buttonsContainer);
            
            // 스크롤을 맨 아래로
            scrollToBottom();
        }
        
        function handleSuggestionClick(suggestion) {
            // 제안 버튼들 숨기기
            const buttonsContainer = document.querySelector('.guide-suggestion-buttons');
            if (buttonsContainer) {
                buttonsContainer.remove();
            }
            
            // "이제 결론을 내줘" 버튼인 경우 종료 로직 실행 (사용자 메시지 추가하지 않음)
            if (suggestion === '이제 결론을 내줘') {
                endDebate();
                return;
            }
            
            // 다른 버튼인 경우에만 사용자 메시지로 표시
            addUserMessage(suggestion);
            
            // 사용자 정보 누적 (일반 사용자 입력과 동일하게 처리)
            if (accumulatedUserInfo) {
                accumulatedUserInfo += ', ' + suggestion;
            } else {
                accumulatedUserInfo = suggestion;
            }
            currentUserInfo = accumulatedUserInfo;
            
            // 마지막 안내봇 질문과 연결
            if (lastGuideQuestion) {
                saveUserQA(lastGuideQuestion, suggestion);
                lastGuideQuestion = ''; // 저장 후 초기화
            }
            
            // 다음 라운드 시작 (일반 사용자 입력과 동일하게 처리)
            continueDebateWithInfo(currentUserInfo);
        }
        
        function showUserInfoSection() {
            document.getElementById('endChatBtn').classList.remove('hidden');
        }

        async function continueDebate() {
            const userInfo = document.getElementById('userInfoInput').value.trim();
            if (!userInfo) {
                alert('추가 정보를 입력해주세요!');
                return;
            }

            currentUserInfo = userInfo;
            isDebating = true;
            document.getElementById('continueBtn').disabled = true;
            document.getElementById('continueBtn').textContent = 'AI가 분석 중...';

            try {
                let response;
                
                if (currentProduct) {
                    response = await fetch('/product/debate/stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            product_id: currentProduct.id,
                            user_info: currentUserInfo,
                            max_turns: 2
                        })
                    });
                } else {
                    response = await fetch('/debate/stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            topic: currentTopic,
                            user_info: currentUserInfo,
                            max_turns: 2
                        })
                    });
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() && line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (jsonStr) {
                                    const data = JSON.parse(jsonStr);
                                    await handleStreamData(data);
                                }
                            } catch (e) {
                                console.error('JSON parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error:', error);
                addStatusMessage('error', '애매하긴해');
            } finally {
                isDebating = false;
                document.getElementById('continueBtn').disabled = false;
                document.getElementById('continueBtn').textContent = '추가 논쟁 시작';
            }
        }

        async function endDebate() {
            const chatMessages = document.getElementById('chatMessages');
            
            // 이미 결정 관련 메시지가 표시되었는지 확인
            const existingDecisionMessage = Array.from(chatMessages.children).find(child => 
                child.className === 'message user' && 
                (child.textContent.includes('이미 결정했긴해') || child.textContent.includes('이제 결론을 내줘'))
            );
            
            // 사용자 메시지로 "이제 결론을 내줘" 표시 (중복 방지)
            if (!existingDecisionMessage) {
                const userMessageDiv = document.createElement('div');
                userMessageDiv.className = 'message user';
                userMessageDiv.innerHTML = `
                    <div class="message-content">
                        이제 결론을 내줘
                    </div>
                `;
                chatMessages.appendChild(userMessageDiv);
                scrollToBottom();
            }
            
            // 최종 요약 가져오기
            try {
                // 타이핑 인디케이터 표시
                showTypingIndicator('안내봇');
                
                const url = accumulatedUserInfo ? `/summary?user_info=${encodeURIComponent(accumulatedUserInfo)}` : '/summary';
                const response = await fetch(url);
                const data = await response.json();
                
                // 타이핑 인디케이터 제거
                hideTypingIndicator();
                
                if (data.success) {
                    // 최종 요약 메시지 표시
                    const endMessageDiv = document.createElement('div');
                    endMessageDiv.className = 'message bot guide guide-turn';
                    endMessageDiv.innerHTML = `
                        <div class="speaker-info">
                            <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                            <span class="speaker-name guide-name">안내봇</span>
                        </div>
                        <div class="message-content">
                            ${highlightKeywords(data.summary)}
                        </div>
                    `;
                    chatMessages.appendChild(endMessageDiv);
                    scrollToBottom();
                    
                    // 최종 결론 후 채팅창 비활성화
                    disableChatInput();
                } else {
                    // 요약 실패 시 기본 메시지
                    const endMessageDiv = document.createElement('div');
                    endMessageDiv.className = 'message bot guide guide-turn';
                    endMessageDiv.innerHTML = `
                        <div class="speaker-info">
                            <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                            <span class="speaker-name guide-name">안내봇</span>
                        </div>
                        <div class="message-content">
                            ${highlightKeywords('논쟁이 종료되었습니다. 도움이 되셨나요?')}
                        </div>
                    `;
                    chatMessages.appendChild(endMessageDiv);
                    scrollToBottom();
                    
                    // 요약 실패 시에도 채팅창 비활성화
                    disableChatInput();
                }
            } catch (error) {
                console.error('요약 가져오기 실패:', error);
                // 오류 시 기본 메시지
                const endMessageDiv = document.createElement('div');
                endMessageDiv.className = 'message bot guide guide-turn';
                endMessageDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                        <span class="speaker-name guide-name">안내봇</span>
                    </div>
                    <div class="message-content">
                        ${highlightKeywords('논쟁이 종료되었습니다. 도움이 되셨나요?')}
                    </div>
                `;
                chatMessages.appendChild(endMessageDiv);
                scrollToBottom();
                
                // 오류 시에도 채팅창 비활성화
                disableChatInput();
            }
            
            // 처음으로 되돌아가기 버튼 추가
            const resetButtonDiv = document.createElement('div');
            resetButtonDiv.className = 'reset-section';
            resetButtonDiv.innerHTML = `
                <button onclick="resetToInitial()" class="reset-button">처음으로 되돌아가기</button>
            `;
            chatMessages.appendChild(resetButtonDiv);
            
            document.getElementById('endChatBtn').classList.add('hidden');
            document.getElementById('chatInput').value = '';
            currentTopic = '';
            currentUserInfo = '';
            accumulatedUserInfo = '';
            
            scrollToBottom();
        }
        
        function resetToInitial() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            currentTopic = '';
            currentUserInfo = '';
            accumulatedUserInfo = '';
            currentProduct = null;
            
            // 제품 정보 섹션 숨기기
            const productInfoSection = document.getElementById('productInfoSection');
            if (productInfoSection) {
                productInfoSection.style.display = 'none';
            }
            
            // 논쟁 상태 초기화
            isDebating = false;
            
            // 채팅창 활성화
            enableChatInput();
            
            // URL 파라미터에서 제품 ID 가져오기
            const urlParams = new URLSearchParams(window.location.search);
            const productId = urlParams.get('product');
            
            if (productId) {
                // 제품 자동 선택 및 논쟁 시작
                setTimeout(() => {
                    selectProductById(productId);
                }, 500);
            } else {
                // 제품이 선택되지 않은 경우 초기 안내봇 메시지 표시
                setTimeout(() => {
                    showInitialGuideMessage();
                }, 500);
            }
        }

        function showInitialGuideMessage() {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot guide guide-turn';
            messageDiv.innerHTML = `
                <div class="speaker-info">
                    <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                    <span class="speaker-name guide-name">안내봇</span>
                </div>
                <div class="message-content">
                    구매와 구독 중 어떤 것이 더 나은지 애매하긴해! 우리가 구매vs구독 중에 제안해줄게.
                </div>
            `;
            chatMessages.appendChild(messageDiv);
            scrollToBottom();

            // 초기 안내 메시지에는 예상응답을 표시하지 않음
        }

        function showStartButton() {
            const chatMessages = document.getElementById('chatMessages');
            
            // 시작 버튼 컨테이너 생성
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'guide-suggestion-buttons';
            
            // 시작 버튼 생성 (예상응답 버튼과 동일한 스타일)
            const startButton = document.createElement('button');
            startButton.className = 'suggestion-btn start-button';
            startButton.textContent = '시작해줘';
            startButton.onclick = handleStartClick;
            
            buttonsContainer.appendChild(startButton);
            chatMessages.appendChild(buttonsContainer);
            scrollToBottom();
        }

        function handleStartClick() {
            // 시작 버튼 제거
            const buttonsContainer = document.querySelector('.guide-suggestion-buttons');
            if (buttonsContainer) {
                buttonsContainer.remove();
            }
            
            // 논쟁 시작
            console.log('논쟁 시작!');
            startProductDebate();
        }

        function disableChatInput() {
            // 채팅 입력창과 전송 버튼 비활성화
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (chatInput) {
                chatInput.disabled = true;
                chatInput.placeholder = '논쟁이 종료되었습니다';
                chatInput.style.opacity = '0.6';
                chatInput.style.cursor = 'not-allowed';
            }
            
            if (sendBtn) {
                sendBtn.disabled = true;
                sendBtn.textContent = '종료됨';
                sendBtn.style.opacity = '0.6';
                sendBtn.style.cursor = 'not-allowed';
            }
            
            console.log('채팅창이 비활성화되었습니다');
        }

        function enableChatInput() {
            // 채팅 입력창과 전송 버튼 활성화
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (chatInput) {
                chatInput.disabled = false;
                chatInput.placeholder = '마음에 드는 답변이 없다면 직접 답변을 입력해보세요!';
                chatInput.style.opacity = '1';
                chatInput.style.cursor = 'text';
            }
            
            if (sendBtn) {
                sendBtn.disabled = false;
                sendBtn.textContent = '전송';
                sendBtn.style.opacity = '1';
                sendBtn.style.cursor = 'pointer';
            }
            
            console.log('채팅창이 활성화되었습니다');
        }

        function addBotMessage(message, botType) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            
            if (botType === 'purchase') {
                messageDiv.className = 'message bot purchase';
                messageDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="bot1.png" alt="구매봇" class="bot-avatar">
                        <span class="speaker-name purchase-name">박구매</span>
                    </div>
                    <div class="message-content">
                        ${highlightKeywords(message)}
                    </div>
                `;
            } else if (botType === 'subscription') {
                messageDiv.className = 'message bot subscription';
                messageDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="bot2.png" alt="구독봇" class="bot-avatar">
                        <span class="speaker-name subscription-name">김구독</span>
                    </div>
                    <div class="message-content">
                        ${highlightKeywords(message)}
                    </div>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        async function handleContinueDebateResponse(response, userInput) {
            // 사용자 메시지 표시
            addUserMessage(userInput);
            document.getElementById('chatInput').value = '';
            
            // 입력 필드 비활성화
            disableChatInput();
            
            // 스트리밍 응답 처리
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                console.log('논쟁 계속 응답:', data);
                                
                                if (data.type === 'turn') {
                                    const turnData = data.data;
                                    
                                    if (turnData.speaker === '안내봇') {
                                        addGuideMessage(turnData.message, turnData.suggestions);
                                    } else if (turnData.speaker === '구매봇' || turnData.speaker === '박구매') {
                                        addBotMessage(turnData.message, 'purchase');
                                    } else if (turnData.speaker === '구독봇' || turnData.speaker === '김구독') {
                                        addBotMessage(turnData.message, 'subscription');
                                    }
                                }
                            } catch (e) {
                                console.error('JSON 파싱 오류:', e);
                            }
                        }
                    }
                }
            } finally {
                // 사용자 입력 활성화
                enableChatInput();
            }
        }

        async function sendUserInfo() {
            const userInfo = document.getElementById('chatInput').value.trim();
            if (!userInfo) {
                alert('상황을 입력해주세요!');
                return;
            }

            // 예상응답 버튼들 숨기기 (사용자가 직접 입력한 경우)
            const buttonsContainer = document.querySelector('.guide-suggestion-buttons');
            if (buttonsContainer) {
                buttonsContainer.remove();
            }
            
            // 개선된 플로우에서 사용자 입력 처리
            if (document.getElementById('useImprovedFlow').checked && waitingForUser) {
                addUserMessage(userInfo);
                document.getElementById('chatInput').value = '';
                
                // 대화 기록에 추가
                conversationHistory.push({
                    speaker: '사용자',
                    message: userInfo,
                    turn: conversationHistory.length + 1
                });
                
                await sendImprovedResponse(userInfo);
                return;
            }

            // 주기 정보 감지 및 가격 업데이트
            const contractInfo = detectContractPeriod(userInfo);
            if (contractInfo && currentProduct) {
                if (contractInfo.unsupported) {
                    // 지원하지 않는 주기인 경우 안내봇 메시지 표시
                    showGuideMessageForUnsupportedContract(contractInfo.period);
                    return; // 논쟁을 시작하지 않음
                } else {
                    updateProductPrice(contractInfo.period, contractInfo.price);
                }
            }
            
            // 사용자 입력 후 논쟁 계속 (구매봇 1번, 구독봇 1번, 안내봇 재등장)
            console.log('사용자 입력 후 논쟁 계속:', userInfo);
            try {
                const response = await fetch('/continue-debate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_input: userInfo,
                        product_id: currentProduct ? currentProduct.id : null
                    })
                });

                if (response.ok) {
                    console.log('논쟁 계속 시작');
                    await handleContinueDebateResponse(response, userInfo);
                    return; // 함수 종료
                }
            } catch (error) {
                console.error('논쟁 계속 오류:', error);
            }

            // 제품 정보 질문 감지
            if (detectProductInfoQuestion(userInfo)) {
                // 먼저 사용자 메시지 표시
                addUserMessage(userInfo);
                document.getElementById('chatInput').value = '';
                
                // 그 다음 안내봇이 제품 정보 설명
                showProductInfoResponse(userInfo);
                return;
            }
            
            // 예산 감지 및 주기 추천
            const budgetInfo = detectBudget(userInfo);
            if (budgetInfo && currentProduct) {
                // 먼저 사용자 메시지 표시
                addUserMessage(userInfo);
                document.getElementById('chatInput').value = '';
                
                // 그 다음 안내봇 메시지 표시
                showBudgetRecommendation(budgetInfo);
                updateProductPrice(budgetInfo.period, budgetInfo.price);
                
                // 예산 정보를 사용자 정보에 추가
                if (accumulatedUserInfo) {
                    accumulatedUserInfo += ', ' + userInfo;
                } else {
                    accumulatedUserInfo = userInfo;
                }
                currentUserInfo = accumulatedUserInfo;
                
                // 예산 질문을 안내봇에게 알림 (중복 질문 방지)
                notifyBudgetAnswered();
                
                continueDebateWithInfo(currentUserInfo);
                return;
            }

            // 사용자 정보 누적
            if (accumulatedUserInfo) {
                accumulatedUserInfo += ', ' + userInfo;
            } else {
                accumulatedUserInfo = userInfo;
            }
            currentUserInfo = accumulatedUserInfo;
            
            // 마지막 안내봇 질문이 있으면 질문-답변 쌍 저장
            if (lastGuideQuestion) {
                saveUserQA(lastGuideQuestion, userInfo);
                lastGuideQuestion = ''; // 저장 후 초기화
            }

            addUserMessage(userInfo);
            document.getElementById('chatInput').value = '';
            continueDebateWithInfo(currentUserInfo);
        }

        function detectContractPeriod(userInput) {
            // 구독 관련 키워드와 함께 사용된 주기만 감지
            const subscriptionKeywords = ['구독', '계약', '월', '가격', '비용', '요금', '할래', '말래'];
            const contractPattern = /(\d+)년/;
            const match = userInput.match(contractPattern);
            
            if (match && currentProduct) {
                const period = match[1] + '년';
                
                // 구독 관련 키워드가 있는지 확인
                const hasSubscriptionKeyword = subscriptionKeywords.some(keyword => 
                    userInput.includes(keyword)
                );
                
                // 이사, 이동, 거주 등과 관련된 문맥은 제외
                const excludeKeywords = ['이사', '이동', '거주', '살고', '살아', '주거', '집', '아파트'];
                const hasExcludeKeyword = excludeKeywords.some(keyword => 
                    userInput.includes(keyword)
                );
                
                // 구독 관련 키워드가 있고, 제외 키워드가 없을 때만 처리
                if (hasSubscriptionKeyword && !hasExcludeKeyword) {
                    let price = null;
                    
                    // 새로운 구조에서 가격 찾기
                    if (currentProduct.subscription_price && typeof currentProduct.subscription_price === 'object') {
                        price = currentProduct.subscription_price[period];
                    } else if (currentProduct.subscription_pricing) {
                        price = currentProduct.subscription_pricing[period];
                    }
                    
                    if (price) {
                        return { period, price };
                    } else {
                        // 지원하지 않는 주기인 경우
                        return { period, price: null, unsupported: true };
                    }
                }
            }
            return null;
        }

        function detectBudget(userInput) {
            // 예산 관련 키워드와 함께 사용된 금액만 감지
            const budgetKeywords = ['예산', '예산이', '예산은', '월', '한달', '한 달', '월급', '돈', '가능', '여유'];
            const budgetPattern = /(\d+)(?:만|천|원)?/g;
            const matches = [...userInput.matchAll(budgetPattern)];
            
            if (matches.length > 0 && currentProduct) {
                // 예산 관련 키워드가 있는지 확인
                const hasBudgetKeyword = budgetKeywords.some(keyword => 
                    userInput.includes(keyword)
                );
                
                if (hasBudgetKeyword) {
                    // 가장 큰 금액을 예산으로 간주
                    let maxBudget = 0;
                    for (const match of matches) {
                        let amount = parseInt(match[1]);
                        if (match[0].includes('만')) {
                            amount *= 10000;
                        } else if (match[0].includes('천')) {
                            amount *= 1000;
                        }
                        maxBudget = Math.max(maxBudget, amount);
                    }
                    
                    // 새로운 구조에서 예산에 맞는 주기 찾기
                    let availablePeriods = [];
                    if (currentProduct.subscription_price && typeof currentProduct.subscription_price === 'object') {
                        availablePeriods = Object.keys(currentProduct.subscription_price);
                    } else if (currentProduct.subscription_pricing) {
                        availablePeriods = Object.keys(currentProduct.subscription_pricing);
                    }
                    
                    let bestPeriod = null;
                    let bestPrice = Infinity;
                    
                    for (const period of availablePeriods) {
                        let price = null;
                        if (currentProduct.subscription_price && typeof currentProduct.subscription_price === 'object') {
                            price = currentProduct.subscription_price[period];
                        } else if (currentProduct.subscription_pricing) {
                            price = currentProduct.subscription_pricing[period];
                        }
                        
                        if (price && price <= maxBudget && price < bestPrice) {
                            bestPeriod = period;
                            bestPrice = price;
                        }
                    }
                    
                    if (bestPeriod) {
                        return { period: bestPeriod, price: bestPrice, budget: maxBudget };
                    }
                }
            }
            return null;
        }

        function detectProductInfoQuestion(userInput) {
            // 명확한 질문 키워드들만 감지
            const questionKeywords = [
                '어떤', '뭐야', '뭔지', '뭐지', '알려줘', '설명', '기능', '특징', 
                '장점', '단점', '가격', '비용', '얼마', '어떻게', '어떤거', 
                '뭐가', '뭔가', '궁금', '궁금해', '궁금한', '알고싶', '알고싶어',
                '이거', '이것', '이게', '이건', '이거는', '이것은'
            ];
            
            // 답변 형태 감지 (질문이 아닌 답변들)
            const answerPatterns = [
                /.*없어$/,  // "없어"로 끝나는 답변
                /.*있어$/,  // "있어"로 끝나는 답변
                /.*살고.*/,  // "살고" 포함 (주거 형태 답변)
                /.*명이야$/,  // "명이야"로 끝나는 답변 (가족 구성원)
                /.*만원.*/,  // 예산 관련 답변
                /.*원.*/,  // 금액 관련 답변
            ];
            
            // 답변 패턴이 있으면 질문이 아님
            const hasAnswerPattern = answerPatterns.some(pattern => pattern.test(userInput));
            if (hasAnswerPattern) {
                return false;
            }
            
            const hasQuestionKeyword = questionKeywords.some(keyword => 
                userInput.includes(keyword)
            );
            
            return hasQuestionKeyword && currentProduct;
        }

        function updateProductPrice(period, price) {
            // 새로운 구조에 맞게 가격 업데이트
            const subscriptionPriceElement = document.querySelector('.subscription-box .price-value');
            const contractPeriodElement = document.querySelector('.subscription-box .contract-period');
            
            if (subscriptionPriceElement) {
                subscriptionPriceElement.textContent = `${price.toLocaleString()}원/월`;
            }
            
            if (contractPeriodElement) {
                contractPeriodElement.textContent = period;
            }
        }

        function showProductInfoResponse(userInput) {
            const chatMessages = document.getElementById('chatMessages');
            const categoryName = currentProduct.name.replace(/WD\d+[A-Z]+|RG\d+[A-Z]+/, '').trim();
            
            // 제품 정보를 간단하게 설명하는 메시지 생성
            let infoMessage = `${categoryName}에 대해 궁금하긴해! `;
            
            // 구매 혜택 중 일부 선택
            const purchaseBenefits = currentProduct.purchase_benefits || [];
            if (purchaseBenefits.length > 0) {
                infoMessage += `구매하면 ${purchaseBenefits[0]} 같은 장점이 있긴해. `;
            }
            
            // 구독 혜택 중 일부 선택
            const subscriptionBenefits = currentProduct.subscription_benefits || [];
            if (subscriptionBenefits.length > 0) {
                infoMessage += `구독하면 ${subscriptionBenefits[0]} 같은 서비스를 받을 수 있긴해. `;
            }
            
            infoMessage += `더 자세한 비교는 구매봇과 구독봇이 논쟁해줄 거긴해!`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot guide';
            messageDiv.innerHTML = `
                <div class="speaker-info">
                    <img src="/static/bot3.jpeg" alt="안내봇" class="bot-avatar">
                    <span class="speaker-name guide-name">안내봇</span>
                </div>
                <div class="message-content">${highlightKeywords(infoMessage)}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function showGuideMessageForUnsupportedContract(period) {
            const chatMessages = document.getElementById('chatMessages');
            const availablePeriods = Object.keys(currentProduct.subscription_pricing);
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot guide guide-turn';
            
            const guideMessage = `아, ${period} 구독은 이 제품에서는 지원하지 않긴해... 현재는 ${availablePeriods.join(', ')} 구독만 가능하긴해. 다른 제품을 보시거나 지원되는 주기로 다시 생각해보시는 게 어떨까?`;
            
            messageDiv.innerHTML = `
                <div class="speaker-info">
                    <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                    <span class="speaker-name guide-name">안내봇</span>
                </div>
                <div class="message-content">
                    ${highlightKeywords(guideMessage)}
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function showBudgetRecommendation(budgetInfo) {
            const chatMessages = document.getElementById('chatMessages');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot guide guide-turn';
            
            const guideMessage = `아, 한달 예산이 ${budgetInfo.budget.toLocaleString()}원이구나! 그럼 ${budgetInfo.period} 구독(${budgetInfo.price.toLocaleString()}원/월)이 딱 맞을 것 같긴해. 예산에 맞는 주기로 가격도 바꿔줄게!`;
            
            messageDiv.innerHTML = `
                <div class="speaker-info">
                    <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                    <span class="speaker-name guide-name">안내봇</span>
                </div>
                <div class="message-content">
                    ${highlightKeywords(guideMessage)}
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addUserMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';
            
            messageDiv.innerHTML = `
                <div class="message-content">${highlightKeywords(message)}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        async function continueDebateWithInfo(userInfo) {
            currentUserInfo = userInfo;
            isDebating = true;
            document.getElementById('sendBtn').disabled = true;
            document.getElementById('sendBtn').textContent = '생각하는 중...';
            document.getElementById('chatInput').disabled = true;

            try {
                let response;
                
                if (currentProduct) {
                    response = await fetch('/product/debate/stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            product_id: currentProduct.id,
                            user_info: currentUserInfo,
                            max_turns: 2
                        })
                    });
                } else {
                    response = await fetch('/debate/stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            topic: currentTopic,
                            user_info: currentUserInfo,
                            max_turns: 2
                        })
                    });
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() && line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6).trim();
                                if (jsonStr) {
                                    const data = JSON.parse(jsonStr);
                                    await handleStreamData(data);
                                }
                            } catch (e) {
                                console.error('JSON parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error:', error);
                addStatusMessage('error', '애매하긴해');
            } finally {
                isDebating = false;
                document.getElementById('sendBtn').disabled = false;
                document.getElementById('sendBtn').textContent = '전송';
                document.getElementById('chatInput').disabled = false;
            }
        }

        // 스트리밍 메시지 상태 관리
        let currentStreamingMessage = null;
        let currentStreamingElement = null;

        async function handleStreamData(data) {
            console.log('Received data:', data);
            
            // 대화 기록에 추가 (개선된 플로우용)
            if (data.type === 'complete' && data.speaker) {
                conversationHistory.push({
                    speaker: data.speaker,
                    message: currentStreamingMessage ? currentStreamingMessage.content : '',
                    turn: data.turn || conversationHistory.length + 1
                });
            }
            
            switch (data.type) {
                case 'start':
                    console.log('Starting debate:', data.message);
                    // 논쟁 시작 메시지 제거
                    break;
                case 'typing':
                    console.log('Showing typing indicator for:', data.speaker);
                    showTypingIndicator(data.speaker);
                    break;
                case 'streaming':
                    // 디버깅: 실제 데이터 구조 확인
                    console.log('DEBUG - Full data object:', data);
                    console.log('DEBUG - data.content:', data.content);
                    console.log('DEBUG - typeof data.content:', typeof data.content);
                    
                    // content 필드 사용 (chunk가 아닌)
                    const messageContent = data.content || data.chunk;  // 폴백 추가
                    console.log('Streaming content from:', data.speaker, 'content:', messageContent, 'length:', messageContent ? messageContent.length : 0);
                    handleStreamingChunk(data.speaker, messageContent, data.turn);
                    break;
                case 'complete':
                    console.log('Complete turn:', data);
                    if (currentStreamingMessage) {
                        console.log(`${data.speaker} 스트리밍 완료: 총 ${currentStreamingMessage.chunkCount}개 청크, ${currentStreamingMessage.content.length}자`);
                        
                        // 남은 청크가 있다면 강제로 완료
                        if (currentStreamingMessage.pendingChunks.length > 0) {
                            console.log(`남은 청크 ${currentStreamingMessage.pendingChunks.length}자 강제 완료`);
                            currentStreamingMessage.content += currentStreamingMessage.pendingChunks;
                            currentStreamingMessage.pendingChunks = '';
                            
                            const messageContent = currentStreamingElement.querySelector('.message-content');
                            if (messageContent) {
                                messageContent.textContent = currentStreamingMessage.content;
                            }
                        }
                    }
                    hideTypingIndicator();
                    // complete 타입은 단순히 스트리밍 완료 신호만 보내므로
                    // 별도의 메시지 추가는 하지 않음 (이미 streaming으로 추가됨)
                    currentStreamingMessage = null;
                    currentStreamingElement = null;
                    break;
                case 'guide_question':
                    // 개선된 플로우: 안내봇 질문과 제안 버튼 표시
                    console.log('Guide question:', data);
                    lastGuideQuestion = data.question;
                    showImprovedSuggestionButtons(data.suggestions);
                    break;
                case 'waiting_user':
                    // 개선된 플로우: 사용자 응답 대기
                    console.log('Waiting for user:', data.message);
                    waitingForUser = true;
                    isDebating = false;
                    document.getElementById('sendBtn').disabled = false;
                    document.getElementById('sendBtn').textContent = '전송';
                    document.getElementById('chatInput').disabled = false;
                    document.getElementById('chatInput').placeholder = '직접 답변을 입력하거나 제안된 답변을 선택하세요';
                    break;
                case 'turn':
                    console.log('Adding turn:', data.data);
                    await addDebateTurn(data.data);
                    break;
                case 'end':
                    console.log('Ending debate:', data.message);
                    waitingForUser = false;
                    // 논쟁이 끝나면 사용자 입력 섹션 표시
                    showUserInfoSection();
                    break;
                case 'error':
                    console.log('Error:', data.message);
                    addStatusMessage('error', '애매하긴해');
                    break;
                default:
                    console.log('Unknown data type:', data);
            }
        }

        function handleStreamingChunk(speaker, chunk, turn) {
            // 청크가 유효한지 확인
            if (!chunk || typeof chunk !== 'string' || !chunk.trim()) {
                console.log('Invalid or empty chunk:', chunk);
                return;
            }
            
            // 첫 번째 청크인 경우 새로운 메시지 요소 생성
            if (!currentStreamingMessage || currentStreamingMessage.speaker !== speaker) {
                hideTypingIndicator();
                
                // 새로운 스트리밍 메시지 생성
                currentStreamingMessage = {
                    speaker: speaker,
                    content: '',
                    turn: turn,
                    pendingChunks: '',
                    isTyping: false,
                    chunkCount: 0
                };
                
                // 메시지 요소 생성
                currentStreamingElement = createStreamingMessageElement(speaker, turn);
                chatMessages.appendChild(currentStreamingElement);
                scrollToBottom();
            }
            
            // 청크를 대기열에 추가
            if (currentStreamingMessage && currentStreamingMessage.speaker === speaker) {
                currentStreamingMessage.pendingChunks += chunk;
                currentStreamingMessage.chunkCount++;
                console.log(`${speaker} 청크 ${currentStreamingMessage.chunkCount}: "${chunk}" (대기열: ${currentStreamingMessage.pendingChunks.length}자)`);
                
                // 타이핑 효과 시작 (이미 진행 중이면 무시)
                if (!currentStreamingMessage.isTyping) {
                    currentStreamingMessage.isTyping = true;
                    typePendingChunks();
                }
            }
        }

        function typePendingChunks() {
            if (!currentStreamingMessage || !currentStreamingMessage.pendingChunks || !currentStreamingElement) {
                return;
            }
            
            const messageContent = currentStreamingElement.querySelector('.message-content');
            if (!messageContent) {
                console.log('Message content element not found');
                return;
            }
            
            // 한 글자씩 추가 (최대 3글자까지 한 번에 처리)
            let charsToAdd = '';
            const maxChars = Math.min(3, currentStreamingMessage.pendingChunks.length);
            
            for (let i = 0; i < maxChars; i++) {
                const nextChar = currentStreamingMessage.pendingChunks.charAt(i);
                if (nextChar) {
                    charsToAdd += nextChar;
                }
            }
            
            if (charsToAdd) {
                currentStreamingMessage.content += charsToAdd;
                currentStreamingMessage.pendingChunks = currentStreamingMessage.pendingChunks.slice(maxChars);
                
                // 메시지 내용 업데이트
                messageContent.textContent = currentStreamingMessage.content;
                
                // 자동 스크롤
                scrollToBottom();
                
                // 다음 글자를 위한 타이머 (30ms 지연)
                if (currentStreamingMessage.pendingChunks.length > 0) {
                    setTimeout(typePendingChunks, 30);
                } else {
                    currentStreamingMessage.isTyping = false;
                    console.log(`타이핑 완료: 총 ${currentStreamingMessage.content.length}자 출력됨`);
                }
            }
        }

        function createStreamingMessageElement(speaker, turn) {
            const messageDiv = document.createElement('div');
            messageDiv.id = `streaming-${speaker}-${turn}`;
            
            // 아바타와 이름 설정
            let botImage, botName, messageClass, alignmentClass;
            
            if (speaker === '구매봇') {
                botImage = 'bot1.jpeg';
                botName = '박구매';
                messageClass = 'purchase';
                alignmentClass = 'bot';
            } else if (speaker === '구독봇') {
                botImage = 'bot2.png';
                botName = '김구독';
                messageClass = 'subscription';
                alignmentClass = 'bot';
            } else if (speaker === '안내봇') {
                botImage = 'bot3.jpeg';
                botName = '안내봇';
                messageClass = 'guide';
                alignmentClass = 'bot';
            }
            
            // 메시지 클래스 설정
            messageDiv.className = `message ${alignmentClass} ${messageClass}`;
            
            if (speaker === '구매봇' || speaker === '안내봇') {
                messageDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="/static/${botImage}" alt="${botName}" class="bot-avatar">
                        <span class="speaker-name ${speaker === '안내봇' ? 'guide-name' : ''}">${botName}</span>
                    </div>
                    <div class="message-content"></div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-content"></div>
                    <div class="speaker-info">
                        <img src="/static/${botImage}" alt="${botName}" class="bot-avatar">
                        <span class="speaker-name">${botName}</span>
                    </div>
                `;
            }
            
            return messageDiv;
        }
        
        // TTS 기능 (숨김)
        let currentAudio = null;
        let autoTTSEnabled = false;
        let speechSpeed = 1.5;  // 고정 속도 (1.5배)
        
        async function generateSpeech(text, voice = 'alloy') {
            try {
                // 먼저 서버 TTS 시도
                const response = await fetch('/tts/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        voice: voice,
                        speed: speechSpeed
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.audio_data) {
                        // base64 데이터를 오디오로 변환
                        const audioBlob = new Blob([
                            Uint8Array.from(atob(data.audio_data), c => c.charCodeAt(0))
                        ], { type: 'audio/mpeg' });
                        
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio(audioUrl);
                        
                        // 기존 오디오가 재생 중이면 정지
                        if (currentAudio) {
                            currentAudio.pause();
                            currentAudio.currentTime = 0;
                        }
                        
                        currentAudio = audio;
                        await audio.play();
                        
                        // 재생 완료 후 URL 해제
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            currentAudio = null;
                        };
                        
                        return true;
                    }
                }
                
                // Azure TTS 실패 시 브라우저 내장 TTS 사용
                console.log('Azure TTS 실패, 브라우저 내장 TTS 사용');
                return await useBrowserTTS(text, voice);
                
            } catch (error) {
                console.error('TTS 오류:', error);
                // 오류 시에도 브라우저 내장 TTS 시도
                return await useBrowserTTS(text, voice);
            }
        }
        
        async function useBrowserTTS(text, voice) {
            try {
                // 기존 오디오가 재생 중이면 정지
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                }
                
                // 브라우저 내장 Speech Synthesis API 사용
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // 음성 선택 (브라우저에서 사용 가능한 음성 중 선택)
                    const voices = speechSynthesis.getVoices();
                    const koreanVoice = voices.find(v => v.lang.startsWith('ko')) || voices[0];
                    if (koreanVoice) {
                        utterance.voice = koreanVoice;
                    }
                    
                    utterance.rate = speechSpeed;  // 사용자가 설정한 속도 사용
                    utterance.pitch = 1.0;
                    utterance.volume = 0.8;
                    
                    // Promise로 래핑
                    return new Promise((resolve) => {
                        utterance.onend = () => {
                            currentAudio = null;
                            resolve(true);
                        };
                        utterance.onerror = () => {
                            currentAudio = null;
                            resolve(false);
                        };
                        
                        speechSynthesis.speak(utterance);
                        currentAudio = utterance; // 현재 재생 중인 음성 저장
                    });
                }
                return false;
            } catch (error) {
                console.error('브라우저 TTS 오류:', error);
                return false;
            }
        }
        
        
        
        function highlightKeywords(text) {
            // 먼저 볼드 태그 처리 (**텍스트**)
            let highlightedText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // 중요한 키워드들을 정의
            const keywords = [
                '구매', '구독', '가격', '비용', '월', '년', '원', '할인', '혜택',
                '관리', 'A/S', '설치', '업그레이드', '최신', '기능', '성능',
                '에너지', '효율', '소음', '디자인', '공간', '크기',
                '보증', '수리', '교체', '유지보수', '케어', '서비스',
                '계약', '기간', '연장', '변경',
                '환경', '친환경', '재활용', '절약',
                '편리', '간편', '쉬움', '번거로움', '부담',
                '안전', '신뢰', '품질', '내구성', '수명',
                '추천', '인기', '베스트', '신제품', '프리미엄'
            ];
            
            // 이미 볼드 태그가 없는 키워드들만 추가로 볼드체로 변경
            keywords.forEach(keyword => {
                const regex = new RegExp(`(?<!<strong>)(?<!\\*\\*)(${keyword})(?!</strong>)(?!\\*\\*)`, 'gi');
                highlightedText = highlightedText.replace(regex, '<strong>$1</strong>');
            });
            
            return highlightedText;
        }
        
        async function addDebateTurn(turnData) {
            const chatMessages = document.getElementById('chatMessages');
            
            // 기존 타이핑 인디케이터 제거
            hideTypingIndicator();
            
            // 안내봇 메시지인 경우 질문으로 저장
            if (turnData.speaker === '안내봇') {
                lastGuideQuestion = turnData.message.trim();
                console.log('안내봇 질문 저장:', lastGuideQuestion);
            }
            
            const messageDiv = document.createElement('div');
            
            if (turnData.speaker === '안내봇') {
                messageDiv.className = 'message bot guide guide-turn';
                messageDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="bot3.jpeg" alt="안내봇" class="bot-avatar">
                        <span class="speaker-name guide-name">안내봇</span>
                    </div>
                    <div class="message-content">
                        ${highlightKeywords(turnData.message)}
                    </div>
                `;
                chatMessages.appendChild(messageDiv);
                
                // 안내봇 메시지 다음에 제안 버튼들 추가
                await addGuideSuggestionButtons();
                
                showUserInfoSection();
                scrollToBottom();
                
                // 질문 추출은 이미 위에서 처리됨
                
                // 자동 TTS 재생
                return;
            }
            
            const botImage = turnData.speaker === '구매봇' ? 'bot1.jpeg' : 'bot2.png';
            const botName = turnData.speaker === '구매봇' ? '구매봇' : '구독봇';
            const messageClass = turnData.speaker === '구매봇' ? 'purchase' : 'subscription';
            const alignmentClass = turnData.speaker === '구매봇' ? 'bot' : 'user'; // 구매봇은 왼쪽, 구독봇은 오른쪽
            
            messageDiv.className = `message ${alignmentClass} ${messageClass}`;
            
            if (turnData.speaker === '구매봇') {
                messageDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="${botImage}" alt="${botName}" class="bot-avatar">
                        <span class="speaker-name">${botName}</span>
                    </div>
                    <div class="message-content">
                        ${highlightKeywords(turnData.message)}
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${highlightKeywords(turnData.message)}
                    </div>
                    <div class="speaker-info">
                        <img src="${botImage}" alt="${botName}" class="bot-avatar">
                        <span class="speaker-name">${botName}</span>
                    </div>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            
            // 자동 TTS 재생
        }
        
        function addStatusMessage(type, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot';
            
            messageDiv.innerHTML = `
                <div class="message-content" style="background: #f8f9fa; color: #666; font-style: italic;">
                    ${message}
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        function showTypingIndicator(speaker) {
            const chatMessages = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'typing-indicator';
            typingDiv.className = 'message bot';
            
            let botImage, botName, messageClass, alignmentClass;
            
            if (speaker === '구매봇') {
                botImage = 'bot1.jpeg';
                botName = '박구매';
                messageClass = 'purchase';
                alignmentClass = 'bot';
            } else if (speaker === '구독봇') {
                botImage = 'bot2.png';
                botName = '김구독';
                messageClass = 'subscription';
                alignmentClass = 'user';
            } else if (speaker === '안내봇') {
                botImage = 'bot3.jpeg';
                botName = '안내봇';
                messageClass = 'guide';
                alignmentClass = 'bot';
            }
            
            typingDiv.className = `message ${alignmentClass} ${messageClass}`;
            
            if (speaker === '구매봇' || speaker === '안내봇') {
                typingDiv.innerHTML = `
                    <div class="speaker-info">
                        <img src="${botImage}" alt="${botName}" class="bot-avatar">
                        <span class="speaker-name ${speaker === '안내봇' ? 'guide-name' : ''}">${botName}</span>
                    </div>
                    <div class="typing-indicator">
                        <div class="typing-dots">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                    </div>
                `;
            } else {
                typingDiv.innerHTML = `
                    <div class="typing-indicator">
                        <div class="typing-dots">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                    </div>
                    <div class="speaker-info">
                        <img src="${botImage}" alt="${botName}" class="bot-avatar">
                        <span class="speaker-name">${botName}</span>
                    </div>
                `;
            }
            
            chatMessages.appendChild(typingDiv);
            scrollToBottom();
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        async function notifyBudgetAnswered() {
            try {
                await fetch('/notify-budget-answered', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });
            } catch (error) {
                console.error('예산 답변 알림 실패:', error);
            }
        }

        async function saveUserQA(question, answer) {
            try {
                await fetch('/user-qa', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        question: question,
                        answer: answer
                    })
                });
            } catch (error) {
                console.error('사용자 질문-답변 저장 실패:', error);
            }
        }

        window.onload = async function() {
            console.log('페이지 로드 완료, 제품 로딩 시작...');
            
            try {
                await loadProducts();
                console.log('제품 로딩 완료, products:', products);
                
                // URL 파라미터 처리
                const urlParams = new URLSearchParams(window.location.search);
                const productId = urlParams.get('product');
                
                if (productId) {
                    console.log('URL에서 제품 ID 감지:', productId);
                    selectProductById(productId);
                } else {
                    // 제품이 선택되지 않은 경우 초기 안내봇 메시지 표시
                    console.log('초기 안내 메시지 표시');
                    showInitialGuideMessage();
                }
            } catch (error) {
                console.error('제품 로딩 실패:', error);
                // 제품 로딩 실패해도 초기 안내 메시지는 표시
                showInitialGuideMessage();
            }
            
            // 엔터키 이벤트 리스너 추가
            document.getElementById('chatInput').addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    sendUserInfo();
                }
            });
        };

        function selectProductById(productId) {
            console.log('제품 ID로 자동 선택 시도:', productId);
            
            // 제품 ID로 직접 찾기
            const product = products.find(p => p.id == productId);
            if (product) {
                console.log('제품 찾음:', product.name);
                currentProduct = product;
                showProductInfo(product);
                document.getElementById('productInfo').classList.remove('hidden');
                showStartButton();
            } else {
                console.log('제품 ID', productId, '를 찾을 수 없습니다.');
                // 제품을 찾을 수 없으면 초기 안내 메시지 표시
                showInitialGuideMessage();
            }
        }

        async function loadProducts() {
            try {
                console.log('제품 목록 로딩 시작...');
                console.log('현재 URL:', window.location.href);
                const response = await fetch('/products');
                console.log('응답 상태:', response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('제품 데이터 응답:', data);
                
                if (data.success && data.products && Array.isArray(data.products)) {
                    products = data.products;
                    console.log('로드된 제품들:', products);
                    console.log('제품 수:', products.length);
                } else {
                    console.error('제품 로딩 실패:', data);
                    alert('제품 목록을 불러오는데 실패했습니다.');
                }
            } catch (error) {
                console.error('Error loading products:', error);
                alert('애매하긴해');
            }
        }

        

        function showProductInfo(product) {
            const productInfo = document.getElementById('productInfo');
            
            // 제품군만 표시 (모델명 제거)
            const categoryName = product.name.replace(/WD\d+[A-Z]+|RG\d+[A-Z]+/, '').trim();
            
            // 제품의 image 필드 사용
            let imageFileName = product.image || '0.png'; // 기본값
            
            // 기본 구독 가격과 주기 표시 (첫 번째 계약 기간 기준)
            let defaultSubscriptionPrice = 0;
            let defaultContractPeriod = '';
            
            // 새로운 JSON 구조에 맞게 가격 정보 처리
            if (product.subscription_price && typeof product.subscription_price === 'object') {
                // subscription_price가 객체인 경우 (새로운 구조)
                const contracts = Object.keys(product.subscription_price);
                if (contracts.length > 0) {
                    defaultContractPeriod = contracts[0];
                    defaultSubscriptionPrice = product.subscription_price[defaultContractPeriod];
                }
            } else if (product.subscription_pricing && Object.keys(product.subscription_pricing).length > 0) {
                // 기존 구조 (subscription_pricing 사용)
                const firstContract = Object.keys(product.subscription_pricing)[0];
                defaultSubscriptionPrice = product.subscription_pricing[firstContract];
                defaultContractPeriod = firstContract;
            } else if (typeof product.subscription_price === 'number') {
                // 단일 가격인 경우
                defaultSubscriptionPrice = product.subscription_price;
                defaultContractPeriod = '기본';
            }
            
            productInfo.innerHTML = `
                <div class="product-image-container">
                    <img src="/static/${imageFileName}" alt="${categoryName}" class="product-info-image">
                </div>
                <div class="product-details">
                    <div class="product-name">${categoryName}</div>
                    <div class="price-boxes">
                        <div class="price-box purchase-box">
                            <div class="price-label">구매</div>
                            <div class="price-value">${product.purchase_price.toLocaleString()}원</div>
                        </div>
                        <div class="vs-divider">VS</div>
                        <div class="price-box subscription-box">
                            <div class="price-label">구독</div>
                            <div class="price-value">${defaultSubscriptionPrice.toLocaleString()}원/월</div>
                            <div class="contract-period">${defaultContractPeriod}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendUserInfo();
            }
        });
    </script>
</body>
</html>